<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VS2022旧版本.NETFramework安装</title>
    <url>/2024/10/16/VS2022%E6%97%A7%E7%89%88%E6%9C%AC-NETFramework%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="VS2022旧版本-NETFramework安装"><a href="#VS2022旧版本-NETFramework安装" class="headerlink" title="VS2022旧版本.NETFramework安装"></a>VS2022旧版本.NETFramework安装</h2><ul>
<li><p>微软官网已经不支持下载.NETFramework v4.0、v4.5, 从网上找了半天</p>
</li>
<li><p>终于从 <code>https://github.com/microsoft/PTVS/issues/6747</code> 找到了解决办法</p>
</li>
<li><p>以下为链接原文(已翻译)</p>
</li>
</ul>
<hr>
<p>如果您出于某种原因仍在使用没有 SDK 的 .NET Framework 版本，那么下面就是我的解决方案。</p>
<p><img src="https://user-images.githubusercontent.com/39024297/187297610-92a70372-1b63-4ecb-a989-9776c94bd6b4.png"></p>
<p>通过 NuGet 直接下载软件包可以解决这个问题。我们访问 <a href="https://www.nuget.org/">https://www.nuget.org/</a> 并查找 Microsoft.NET.Framework.Reference.Assemblies，选择所需的版本并直接下载软件包。</p>
<p><img src="https://user-images.githubusercontent.com/39024297/187298141-f6c5ae52-848c-4d92-aa89-67d85d0250e1.png"></p>
<p>现在将 .nupkg 文件作为压缩文件打开，转到 &#x2F;build&#x2F;.NETFramework&#x2F; 并解压包含版本的文件夹，路径如下：C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework.NETFramework （如果包含当前版本的文件夹已经存在，将其删除即可）。应该是这样的:</p>
<p><img src="https://user-images.githubusercontent.com/39024297/187299475-3111be8a-7028-4003-a0fe-19b81fd979cc.png"></p>
<p>现在一切正常了！</p>
<hr>
<p>如果您以某种方式保留了一个使用 .NET Framework 2.0 或 3.0 或 3.5 的项目，下面是为您提供的解决方案！</p>
<p>打开 “开始”，输入 “Windows 功能”，然后选中 .NET Framework 3.5（包括 .NET 2.0 和 3.0）。</p>
<p><img src="https://user-images.githubusercontent.com/39024297/187298941-df82244a-400b-43d1-a638-14dc41621ffc.png"></p>
<p>必须启用 Windows 更新，否则将无法运行</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>dotNet高级编程</title>
    <url>/2024/09/05/dotNet%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="C-的数据结构"><a href="#C-的数据结构" class="headerlink" title="C#的数据结构"></a>C#的数据结构</h2><p>Arraylist 自定义类型 类似py的list 存在装拆箱</p>
<p>List 更安全的版本 创建前需要声明类型 不用装箱拆箱（上面这两者的区别可能会考）</p>
<p>Hashtable 类似于dict 是哈希代码组织起来的键值和对的集合 </p>
<blockquote>
<p><strong>Hashtable中key-value键值对均为object类型</strong>，所以在存储或检索值类型时通常发生装箱和拆箱的操作 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型。</p>
</blockquote>
<p>字典Dictionary 需要声明类型 HashTable不支持<strong>泛型</strong>，而Dictionary支持泛型。</p>
<blockquote>
<p>Dic是类型安全的，这有助于我们写出更健壮更具可读性的代码，而且省却我们强制转化的麻烦。当K或V是值类型时，其速度远远超过Hashtable。我认为应该始终使用Dictionary&lt;K, V&gt;，即使要用Hashtable了，也可以用Dictionary&lt;object, object&gt;来替代。</p>
</blockquote>
<p>HashSet 包含不重复项的无序列表</p>
<p>LinkedList 链表</p>
<p>Stack 堆栈 先进后出 push pop</p>
<p>Queue 队列 先进先出 enqueue dequeue</p>
<blockquote>
<p>记录于2023.7.19 一些有的没的废话，今天脖子又开始疼了希望人没事。昨天和老师聊一聊被鼓励到了感觉自己找到心仪工作希望还是挺大的。</p>
</blockquote>
<p><strong>引用类型</strong> string int[] class interface 存在堆上</p>
<p><strong>值类型</strong> int float bool struct 存在栈上</p>
<p>（PS：值类型如果作为引用类型的成员，那么会在堆里）</p>
<p><img src="https://pic4.zhimg.com/80/v2-566d3b8e48c8573d0986420b0beb86df_1440w.jpg" alt="img"></p>
<p><strong>尽量避免拆装</strong></p>
<p>值-&gt;引用 <strong>装箱</strong> object b &#x3D; (object)a （可以理解为多套了一层壳把引用放栈上，实际数据放堆上了）</p>
<p>引用-&gt;值 <strong>拆箱</strong> int c &#x3D; a</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="C-的垃圾回收（GC）"><a href="#C-的垃圾回收（GC）" class="headerlink" title="C#的垃圾回收（GC）"></a>C#的垃圾回收（GC）</h3><p>是.net 中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存（堆）中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC 会自动进行。减轻内存管理的压力，将管理从程序编写转化到了运行时。</p>
<p>步骤：首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。</p>
<p><strong>一些概念</strong></p>
<p>对象代龄：每活过一次垃圾回收就+1变成第n代对象。可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度。</p>
<p>强制垃圾回收用函数GC.Collect() </p>
<p>单个对象回收时调用析构函数 Object.Finalize() 或者 如果需要强制回收可以手动调用Dispose()方法</p>
<h2 id="C-委托delegate"><a href="#C-委托delegate" class="headerlink" title="C# 委托delegate"></a><strong>C# 委托delegate</strong></h2><p><a href="https://www.cnblogs.com/SkySoot/archive/2012/04/05/2433639.html">C# 中的委托和事件(详解) - SkySoot - 博客园</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/620002450">彻底弄懂C#中delegate、event、EventHandler、Action、Func的使用和区别 - 知乎 (zhihu.com)</a></p>
<p>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If … Else(Switch)语句，同时使得程序具有更好的可扩展性。在我看来委托是一类相同函数（返回值类型与参数列表一致）的链表。往委托里面添加方法，就是添加这个特定返回值类型的方法进一个链表，在执行委托的时候依次执行他们。</p>
<p>C#的委托通过delegate关键字来声明。</p>
<p>显式地声明委托: 相当于定义了一种类， 这个类即为一个接受一个参数x的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式:</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate1</span> (<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line"><span class="function"><span class="comment">//第二种方式:</span></span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate2</span>&lt;<span class="title">T</span>&gt;(<span class="params">T x </span>)</span></span><br></pre></td></tr></table></figure>

<p>使用委托: 创建实例，即将一个函数作为委托实例存在。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式:</span></span><br><span class="line">MyDelegate1 mydelegate = <span class="keyword">new</span> MyDelegate1( func )</span><br><span class="line"><span class="comment">//第二种方式:</span></span><br><span class="line">MyDelegate1 mydelegate = func</span><br></pre></td></tr></table></figure>

<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Good Morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;早上好, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, GreetingDelegate MakeGreeting</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeGreeting(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GreetPeople(<span class="string">&quot;Liker&quot;</span>, EnglishGreeting);</span><br><span class="line">        GreetPeople(<span class="string">&quot;李志中&quot;</span>, ChineseGreeting);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>Action（不带返回值的委托）</p>
<p>Func（返回值为int，最后的参数需要和委托的函数的返回值类型保持一致）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action m_action = <span class="built_in">delegate</span>()&#123;</span><br><span class="line">    Debug.log(<span class="string">&quot;rua&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> Action&lt;<span class="built_in">int</span>&gt; m_action;</span><br><span class="line">action();</span><br></pre></td></tr></table></figure>

<p><strong>多播委托</strong></p>
<p>直接+&#x3D;加-&#x3D;减各种委托到委托类型上面可以同时执行这些函数</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action action = Show1;</span><br><span class="line">action += Show2;</span><br><span class="line">action -=Show2;</span><br><span class="line">action -=Show1;</span><br><span class="line">action();</span><br></pre></td></tr></table></figure>

<h3 id="Event-（委托修饰符）"><a href="#Event-（委托修饰符）" class="headerlink" title="Event （委托修饰符）"></a><strong>Event （委托修饰符）</strong></h3><p><strong>关键字event在实例化委托时使用而非定义委托时使用。</strong>它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private 的。在类的外部，注册“+&#x3D;”和注销“-&#x3D;”的访问限定符与你在声明事件时使用的访问符相同。</p>
<p>简单的理解为：event是一种特殊的委托，它只能+&#x3D;，-&#x3D;，不能直接用&#x3D;</p>
<p>经过长久的经验积累后，人们发现，绝大多数事件的定义，是用public delegate void XXX(object sender, EventArgs e);这样一个委托原型进行定义的。所以后来普遍使用EventHandler来定义上面的情况。表示用于处理不具有事件数据的事件的方法。</p>
<p>下面是一个例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.Activated += <span class="keyword">new</span> EventHandler(Form1_Activated);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.Activated=你吃完饭;</span><br><span class="line">Form1_Activated=喊我一声</span><br></pre></td></tr></table></figure>

<p>我委托你吃完饭了，喊我一声。这样我就不用过一会就来看一下你吃完了没有了，已经委托你了。</p>
<h3 id="委托在观察者模式的应用"><a href="#委托在观察者模式的应用" class="headerlink" title="委托在观察者模式的应用"></a>委托在观察者模式的应用</h3><p>当我需要做一个鼠标点击响应的任务时，如果给每一个鼠标类都继承上一堆ClickHandler就显得非常笨比。那么我们可以创建一个EventListener来统一管理这种事件。代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIEventListener</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerClickHandler</span>, <span class="title">IPointerEnterHandler</span>, <span class="title">IPointerExitHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义事件代理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">UIEventProxy</span>(<span class="params">GameObject gb</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 鼠标点击事件</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">event</span> UIEventProxy OnClick;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 鼠标进入事件</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">event</span> UIEventProxy OnMouseEnter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 鼠标滑出事件</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">event</span> UIEventProxy OnMouseExit;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (OnClick != <span class="literal">null</span>)</span><br><span class="line">			OnClick (<span class="keyword">this</span>.gameObject);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (OnMouseEnter != <span class="literal">null</span>)</span><br><span class="line">			OnMouseEnter (<span class="keyword">this</span>.gameObject);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (OnMouseExit != <span class="literal">null</span>)</span><br><span class="line">			OnMouseExit (<span class="keyword">this</span>.gameObject);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际需要使用的时候，可以直接创建一个普通的TestEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEvent</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">		Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt; ();</span><br><span class="line">		UIEventListener btnListener = btn.gameObject.AddComponent&lt;UIEventListener&gt; ();<span class="comment">//添加UIEventListener类</span></span><br><span class="line"></span><br><span class="line">		btnListener.OnClick += <span class="built_in">delegate</span>(GameObject gb) &#123;</span><br><span class="line">			Debug.Log(gb.name + <span class="string">&quot; OnClick&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		btnListener.OnMouseEnter += <span class="built_in">delegate</span>(GameObject gb) &#123;</span><br><span class="line">			Debug.Log(gb.name + <span class="string">&quot; OnMouseEnter&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		btnListener.OnMouseExit += <span class="built_in">delegate</span>(GameObject gb) &#123;</span><br><span class="line">			Debug.Log(gb.name + <span class="string">&quot; OnMOuseExit&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lnvoke"><a href="#lnvoke" class="headerlink" title="lnvoke"></a>lnvoke</h2><p>调用、执行的意思。在应用程序的主线程上执行指定的<strong>委托</strong>。一般应用：在辅助线程中修改UI线程（ 主线程 ）中对象的属性时。</p>
<p>Invoke(string methodName，float time):输入一个方法名称，过个几秒来执行一次</p>
<p>methodName:方法名称time:几秒后执行</p>
<p>InvokeRepeating(string methodName，float time，float repeatRate):重复调用</p>
<p>methodName :方法名称time :几秒后执行</p>
<p>repeatRate:重复间隔时间</p>
<p>Cancellnvoke(string methodName):取消调用，使用无参重载就是取消全部</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>就是“协同程序”，并不是多线程。</p>
<p>既然叫协同，所以还有一个主程序，那么这个主程序其实就是我们的目前学习到的各种生命周期函数</p>
<h3 id="为什么需要协程"><a href="#为什么需要协程" class="headerlink" title="为什么需要协程?"></a>为什么需要协程?</h3><p>主程序已经在执行某个任务，希望“同时运行”其他逻辑，这里的同时，并不是多线程意义上的同时，只是感官上是同时。</p>
<p><strong>协程的使用场景</strong></p>
<p>对于保证不会阻塞的并行操作且并行性要求不高的并行操作，可以使用协程。更实际来说，协程最常用于延时执行等控制时间轴的操作，例如1、N秒后调用指定函数。2、一个游戏物体的颜色渐渐变淡，直至消失。3、异步加载资源</p>
<p>利用每帧执行一段协程的特性，我们可以引入个带累加计时判断循环，然后再超过3秒后跳出循环，执行Debug.Log()</p>
<h3 id="为什么不考虑多线程"><a href="#为什么不考虑多线程" class="headerlink" title="为什么不考虑多线程"></a>为什么不考虑多线程</h3><p>因为在Unity中，只能在主线程中获取物体的组件、方法、对象，如果脱离这些，Unity的很多功能无法实现，那么多线程的存在与否意义就不大了</p>
<h3 id="线程与协程的区别："><a href="#线程与协程的区别：" class="headerlink" title="线程与协程的区别："></a>线程与协程的区别：</h3><ul>
<li>对于协程而言，同一时间只能执行一个协程，而线程则是并发的，可以同时有多个线程在运行</li>
<li>两者在内存的使用上是相同的，共享堆，不共享栈</li>
<li>协程跟多线程类似，也有类似异步的效果（注意不是真正的异步）。只不过它的切分粒度不是基于系统划分的时间片，而是基于我们编写的yield，而且往往粒度更大。因为它的粒度相对多线程的大很多，所以往往很少出现冲突现象</li>
</ul>
<p>协程的运行逻辑使用</p>
<p>函数声明前缀IEnumerator</p>
<p>yield return new WaitForSeconds(1.0f) 来等待。</p>
<p>调用协程 Coroutine Cor1 &#x3D; StartCoroutine(Demo()); 返回值用来标识特定的协程，多个同名协程启动时使用</p>
<p>结束协程 StopCoroutine()输入不建议用字符串取消，而是用上面的Coroutine类型作为参数取消目标。</p>
<p>例如 如果某一时刻需要使用Update读取一个列表，这样一般需要一个循环去遍历列表，这样每帧的代码执行量就比较大，就可以将这样的执行放置到协程中来处理</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; nums = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(PrintNum(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过协程分帧处理</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">PrintNum</span>(<span class="params">List&lt;<span class="built_in">int</span>&gt; nums</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> nums)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(i);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><a href="https://zhuanlan.zhihu.com/p/279383752">宇亓：Unity协程的原理与应用</a></p>
<p>StartCoroutine 接受到的是一个 IEnumerator ，这是个接口，并且是枚举器或迭代器的意思。 因此我们可以说协程本体是一个<strong>C#的迭代器遍历函数。</strong></p>
<p>当一个方法的返回值写成了IEnumerator类型，他就会自动被解析成迭代器方法<em>（后文直接称之为协程）</em>，你调用此方法的时候不会真的运行，而是会返回一个迭代器，需要用MoveNext()来真正的运行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IEnumerator it = Test();<span class="comment">//仅仅返回一个指向Test的迭代器，不会真的执行。</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">    it.MoveNext();<span class="comment">//执行Test直到遇到第一个yield</span></span><br><span class="line">    System.Console.WriteLine(it.Current);<span class="comment">//输出1</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">    it.MoveNext();<span class="comment">//执行Test直到遇到第二个yield</span></span><br><span class="line">    System.Console.WriteLine(it.Current);<span class="comment">//输出2</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">    it.MoveNext();<span class="comment">//执行Test直到遇到第三个yield</span></span><br><span class="line">    System.Console.WriteLine(it.Current);<span class="comment">//输出test3</span></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerator <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.Console.WriteLine(<span class="string">&quot;第一次执行&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    System.Console.WriteLine(<span class="string">&quot;第二次执行&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    System.Console.WriteLine(<span class="string">&quot;第三次执行&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;test3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用IEnumerator.MoveNext()时会把协程方法体压入当前的函数调用栈中执行，运行到yield return后再弹栈。这点和有些语言中的协程不大一样，有些语言的协程会维护一个自己的函数调用栈，在唤醒的时候会把整个函数调用栈给替换，这类协程被称为<strong>有栈协程</strong>，而像C#中这样直接在当前函数调用栈中压入栈帧的协程我们称之为<strong>无栈协程</strong>。</p>
<p>yield 是 C#的一个关键字，也是一个语法糖<em>（这种语法对语言的功能没有影响，但是更方便<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98">程序员</a>使用）</em>，背后的原理会生成一个类，并且也是一个<strong>枚举器</strong>，而且不同于 return，yield 可以出现多次。 </p>
<p>yield 实际上就是返回一次结果，因为我们要一次一次枚举一个值出来，所以<strong>多个 yield 其实是个状态模式</strong>，第一个 yield 是状态 1，第二个 yield 是状态 2，每次访问时会基于状态知道当前应该执行哪一个 yield，取得哪一个值。 </p>
<p>使用较多的“暂停 XX 秒” yield return new WaitForSeconds(0.5f)，其实本质上就是每一帧都来检查一次是否满足了计时条件，如果满足就说明 yield 的状态满足了， 进入下一个状态，至于 yield return null，为什么会有暂停一帧的效果，因为相当于 什么也没做，但是检查需要在下一帧进行。</p>
<h2 id="C-引用传递-in-ref-out"><a href="#C-引用传递-in-ref-out" class="headerlink" title="C# 引用传递 in ref out"></a>C# 引用传递 in ref out</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i,<span class="keyword">ref</span> <span class="built_in">int</span> j</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = i;</span><br><span class="line">        i = j;</span><br><span class="line">        j = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ref 用于传递引用值，比起C++直接采用指针实现传值更加安全。当通过引用传递时，不会对值类型装箱。它让形参成为实参的别名，这必须是变量。</p>
<p>in 关键字会导致按引用传递参数，但确保未修改参数。 这通常用于传递一些巨大的结构体，并且只进行读操作。</p>
<p>out关键字通过引用传递参数。作为out参数传递的变量在方法调用中传递之前不必进行初始化。 但是，被调用的方法需要在返回之前赋一个值。</p>
<h2 id="C-不安全代码unsafe"><a href="#C-不安全代码unsafe" class="headerlink" title="C# 不安全代码unsafe"></a>C# 不安全代码unsafe</h2><p>当一个代码块使用<strong>unsafe</strong>修饰符标记时，C# 允许在函数中使用指针变量（<strong>指针变量</strong>值为另一个变量的地址）。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块。</p>
<h2 id="x3D-gt-的用法"><a href="#x3D-gt-的用法" class="headerlink" title="&#x3D;&gt;的用法"></a>&#x3D;&gt;的用法</h2><p>有两种用法，最常见的是1、Lamba表达式的用法跟C++的<code>-&gt;</code>类似。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数指针的对象, 也就是委托, 其函数签名为string f(Person)</span></span><br><span class="line">Func&lt;Person, <span class="built_in">string</span>&gt; nameProjection = p =&gt; p.Name;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>也可以当做一个语法糖使用，用来表示某个取值get，也就是expression-bodied members。用法为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MaxHealth1 =&gt; x ? y:z;</span><br><span class="line"><span class="comment">//这个等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MaxHealth1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x ? y:z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一个Property，设置了getter，每次访问该值的时候，都会调用x?y:z表达式</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>docker相关命令</title>
    <url>/2024/10/11/docker%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<h2 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##以下面yml文件为例</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器状态相关</span></span><br><span class="line">docker-compose ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker-compose logs -f h5st</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入对应容器打开一个bash终端</span></span><br><span class="line">docker-compose exec mix bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">验证并显示docker-compose.yml文件的配置内容</span></span><br><span class="line">docker-compose config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker-compose pull h5st</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后台启动一个容器</span></span><br><span class="line">docker-compose up -d h5st</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止容器</span></span><br><span class="line">docker-compose stop h5st</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除容器</span></span><br><span class="line">docker-compose rm h5st</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有服务的镜像信息</span></span><br><span class="line">docker-compose images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi [镜像id]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看镜像摘要值-sha256</span></span><br><span class="line">docker inspect [镜像id]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>docker-compose.yml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.7.6&#x27;</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">macnet:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">macvlan</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nolan_pro:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nolan_pro</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nolanhzy/pro:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jdWskeyWeb:/app/Data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 授权码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Prolic=xxxxxx</span></span><br><span class="line">      <span class="comment"># 自定义管理帐号</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">User=xxxxxx</span></span><br><span class="line">      <span class="comment"># 自定义管理密码(八位以上包含大小写字母、数字或特殊字符)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Pwd=xxxxx</span></span><br><span class="line">    <span class="comment"># 设置容器的权限为root</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5016</span><span class="string">:5016</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">macnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.37</span></span><br><span class="line">  <span class="attr">mix:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">whyour/qinglong:debian-python3.10</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mix</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">mix</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mix/ql:/ql/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mix/ql/apk:/var/cache/apk</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mix/ql/global:/root/.local/share/pnpm/global</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mix/ql/site-packages:/usr/local/lib/python3.10/site-packages</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">macnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.36</span></span><br><span class="line">  <span class="attr">ql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">whyour/qinglong:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ql</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">ql</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd/ql:/ql/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/bin/docker:/usr/bin/docker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd/ql/apk:/var/cache/apk</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd/ql/global:/root/.local/share/pnpm/global</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd/ql/site-packages:/usr/local/lib/python3.10/site-packages</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">macnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.35</span></span><br><span class="line">  <span class="attr">jd:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">whyour/qinglong:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jd</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jd</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd2/ql:/ql/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd2/ql/apk:/var/cache/apk</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd2/ql/global:/root/.local/share/pnpm/global</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd2/ql/site-packages:/usr/local/lib/python3.10/site-packages</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">macnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.38</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jd_sign:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;docker.fxxk.dedyn.io/zhx47/jd_sign:latest&quot;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jd_sign</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jd_sign</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jd_sign:/app/data</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">json-file</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">max-file:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">&quot;50m&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">macnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.41</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">h5st:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;dockerproxy.cn/zhx47/jd_h5st_server:amd64&quot;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">h5st</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">h5st</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">json-file</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">max-file:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">&quot;50m&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">macnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.31</span><span class="number">.42</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本操作</title>
    <url>/2023/01/17/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Git 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull.<br><img src="https://pic.imgdb.cn/item/63df62d34757feff33131295.jpg"></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初始化仓库,在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加当前所有文件到缓存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment">#提交暂存区中的内容到本地仓库 -m:提交的信息</span></span><br><span class="line">git commit -m <span class="string">&quot;信息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#本地与远程仓库连接</span></span><br><span class="line">git remote add origin &lt;远程仓库链接&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果远程仓库创建了readme文件，可以先把远程仓库的项目pull下来</span></span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">#将本地的分支版本上传到远程并合并, git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;, -u 参数指定一个默认主机</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="git分支常用命令"><a href="#git分支常用命令" class="headerlink" title="git分支常用命令"></a>git分支常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出本地所有分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换分支</span></span><br><span class="line">git checkout 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并指定分支到当前分支</span></span><br><span class="line">git merge 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除分支</span></span><br><span class="line">git branch -d 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">git push origin --delete 分支名</span><br><span class="line">git branch -dr 分支名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#克隆到指定的目录</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前配置有哪些远程仓库</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="comment">#加上 -v 参数，可以看到每个别名的实际链接地址</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库，shortname(在本地仓库中对远程仓库起的别名) url(远程仓库地址)</span></span><br><span class="line">git remote add &lt;shortname&gt; &lt;repo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#移除远程仓库关联</span></span><br><span class="line">git remote <span class="built_in">rm</span> &lt;shortname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#从远程仓库下载新分支与数据</span></span><br><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#从远端仓库提取数据并尝试合并到当前分支</span></span><br><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示当前的 git 配置信息</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑 git 配置文件:</span></span><br><span class="line">git config -e    <span class="comment"># 针对当前仓库 </span></span><br><span class="line">git config -e --global   <span class="comment"># 针对系统上所有仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置提交代码时的用户信息</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git config --global user.email xxxxxxxx@yyyy.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署</title>
    <url>/2024/10/11/hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. </p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/docs/writing.html">More</a></p>
<h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/docs/server.html">More</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/docs/generating.html">More</a></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/docs/one-command-deployment.html">More</a></p>
<h3 id="脚本部署-运行-sh-deploy-sh"><a href="#脚本部署-运行-sh-deploy-sh" class="headerlink" title="脚本部署(运行 sh deploy.sh)"></a>脚本部署(运行 sh deploy.sh)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ping不通外网的解决方案(centos)</title>
    <url>/2023/02/05/ping%E4%B8%8D%E9%80%9A%E5%A4%96%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88(centos)/</url>
    <content><![CDATA[<p>ping 不通外网，绝大部分原因是由于dns服务器没有配置导致的问题<br><img src="https://pic.imgdb.cn/item/63df62694757feff3312485e.png"></p>
<h3 id="1、修改配置文件添加DNS"><a href="#1、修改配置文件添加DNS" class="headerlink" title="1、修改配置文件添加DNS"></a>1、修改配置文件添加DNS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#xxx为对应网卡</span></span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加DNS</span></span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure>

<h3 id="2、添加DNS服务器"><a href="#2、添加DNS服务器" class="headerlink" title="2、添加DNS服务器"></a>2、添加DNS服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加如下两行：</span></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure>

<h3 id="3、重启网络"><a href="#3、重启网络" class="headerlink" title="3、重启网络"></a>3、重启网络</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli c reload</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">systemctl restart network</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>

<h3 id="4、如果上述操作还是没有成功"><a href="#4、如果上述操作还是没有成功" class="headerlink" title="4、如果上述操作还是没有成功"></a>4、如果上述操作还是没有成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加默认网关</span></span><br><span class="line">sudo route add default gw 192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后</span></span><br><span class="line">sudo nmcli c reload</span><br></pre></td></tr></table></figure>
<p>到此一般都没问题了😀</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>pve配置及常见问题处理</title>
    <url>/2023/07/29/pve%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="PVE服务器配置及常见问题处理"><a href="#PVE服务器配置及常见问题处理" class="headerlink" title="PVE服务器配置及常见问题处理"></a>PVE服务器配置及常见问题处理</h1><h2 id="0、常用命令"><a href="#0、常用命令" class="headerlink" title="0、常用命令"></a>0、常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看虚拟机列表</span></span><br><span class="line">qm list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pve重启</span></span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看集群资源状况</span></span><br><span class="line">pvesh get /cluster/resources</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">取得虚拟机当前状态 `pvesh get /nodes/&lt;节点<span class="built_in">id</span>&gt;/qemu/&lt;虚拟机<span class="built_in">id</span>&gt;/status/current`</span></span><br><span class="line">pvesh get /nodes/pve/qemu/103/status/current</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭虚拟机 `pvesh create /nodes/&lt;节点<span class="built_in">id</span>&gt;/qemu/&lt;虚拟机<span class="built_in">id</span>&gt;/status/stop`</span></span><br><span class="line">pvesh create /nodes/pve/qemu/103/status/stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动虚拟机 `pvesh create /nodes/&lt;节点<span class="built_in">id</span>&gt;/qemu/&lt;虚拟机<span class="built_in">id</span>&gt;/status/start`</span></span><br><span class="line">pvesh create /nodes/pve/qemu/103/status/start</span><br></pre></td></tr></table></figure>

<h2 id="1、新装配置"><a href="#1、新装配置" class="headerlink" title="1、新装配置"></a>1、新装配置</h2><p>取消订阅</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/data.status !== &#x27;Active&#x27;/false/g&quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br></pre></td></tr></table></figure>
<p>更换源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/apt/sources.list.d/pve-enterprise.list</span><br><span class="line"></span><br><span class="line">wget http://download.proxmox.com/debian/proxmox-ve-release-6.x.gpg -O /etc/apt/trusted.gpg.d/proxmox-ve-release-6.x.gpg</span><br><span class="line"></span><br><span class="line">echo &quot;deb http://download.proxmox.com/debian/pve buster pve-no-subscription&quot; &gt;/etc/apt/sources.list.d/pve-install-repo.list</span><br><span class="line"></span><br><span class="line">echo &quot;deb http://mirrors.aliyun.com/debian/ buster main non-free contrib  </span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib  </span><br><span class="line">deb http://mirrors.aliyun.com/debian-security buster/updates main  </span><br><span class="line">deb-src http://mirrors.aliyun.com/debian-security buster/updates main  </span><br><span class="line">deb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib  </span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib  </span><br><span class="line">deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib  </span><br><span class="line">deb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib&quot; &gt;/etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">apt update</span><br></pre></td></tr></table></figure>


<p>更换LXC国内源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -rn &quot;download.proxmox.com&quot; /usr/share/perl5/PVE/\* #查找设定下载源的文件  </span><br><span class="line">sed -i.bak &quot;s#http://download.proxmox.com/images#https://mirrors.ustc.edu.cn/proxmox/images#g&quot; /usr/share/perl5/PVE/APLInfo.pm  </span><br><span class="line">wget -O /var/lib/pve-manager/apl-info/mirrors.ustc.edu.cn https://mirrors.ustc.edu.cn/proxmox/images/aplinfo-pve-6.dat</span><br></pre></td></tr></table></figure>
<p>安装时间同步服务  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install ntp -y</span><br></pre></td></tr></table></figure>
<h2 id="2、虚拟机迁移时需要确认几个问题"><a href="#2、虚拟机迁移时需要确认几个问题" class="headerlink" title="2、虚拟机迁移时需要确认几个问题"></a>2、虚拟机迁移时需要确认几个问题</h2><ul>
<li>先将虚拟机的磁盘 通过硬件 中的 迁移磁盘 移到共享磁盘中。  </li>
<li>再用迁移，将服务迁移过去。  </li>
<li>迁移时需确认硬件，目标服务器是否满足硬盘需求。不能满足的需要先调整。</li>
</ul>
<h2 id="3、硬盘空间调小"><a href="#3、硬盘空间调小" class="headerlink" title="3、硬盘空间调小"></a>3、硬盘空间调小</h2><h4 id="3-1调整虚拟机硬盘的大小"><a href="#3-1调整虚拟机硬盘的大小" class="headerlink" title="3.1调整虚拟机硬盘的大小"></a>3.1调整虚拟机硬盘的大小</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看虚拟机硬盘信息</span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看虚拟机硬盘路径</span></span><br><span class="line">lvdisplay</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看虚拟机硬盘大小</span>  </span><br><span class="line">lvs  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调小虚拟机硬盘2G，备注：调整前先将系统内的硬盘调为未分配状态。</span>  </span><br><span class="line">lvreduce -L -2G /dev/pve/vm-100-disk-0</span><br></pre></td></tr></table></figure>


<h4 id="3-2增加-或减小-local-目录的大小即扩容"><a href="#3-2增加-或减小-local-目录的大小即扩容" class="headerlink" title="3.2增加 或减小 local 目录的大小即扩容"></a>3.2增加 或减小 local 目录的大小即扩容</h4><p>首先执行命令 <code>fdisk -l</code> ，查看&#x2F;dev&#x2F;mapper&#x2F;pve-root大小，显示内容大概如下面的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Disk /dev/mapper/pve-root: 4.5 GiB, 4831838208 bytes, 9437184 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>
<p>然后对 &#x2F;dev&#x2F;mapper&#x2F;pve-root 扩容，命令如下，即增加1G的空间.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend -L +1G /dev/mapper/pve-root</span><br></pre></td></tr></table></figure>
<p>执行后实际大小其实是还不会变化的,还需要下边的命令, 作用是执行上边的扩容操作  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/mapper/pve-root</span><br></pre></td></tr></table></figure>

<h4 id="3-3如何要删除-local-vm-然后把所有的空间都移到-local下，那么如何操作。"><a href="#3-3如何要删除-local-vm-然后把所有的空间都移到-local下，那么如何操作。" class="headerlink" title="3.3如何要删除 local-vm 然后把所有的空间都移到 local下，那么如何操作。"></a>3.3如何要删除 local-vm 然后把所有的空间都移到 local下，那么如何操作。</h4><ul>
<li><p>先移除local-lvm对应的逻辑卷pve&#x2F;data</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvremove pve/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>对local对应的逻辑卷&#x2F;dev&#x2F;mapper&#x2F;pve-root进行在线扩容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lvextend -l +100%FREE -r /dev/mapper/pve-root</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后实际大小其实是还不会变化的,还需要下边的命令, 作用是执行上边的扩容操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/mapper/pve-root</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web中依次展开数据中心-存储，编辑local-lvm，把local-lvm中对应节点移除即可。</p>
</li>
<li><p>还有在数据中心-存储，编辑local，内容下拉菜单中把所有的内容都选上，以便这个空间可以储存磁盘映像。</p>
</li>
</ul>
<h2 id="4、开启PVE嵌套虚拟化功能"><a href="#4、开启PVE嵌套虚拟化功能" class="headerlink" title="4、开启PVE嵌套虚拟化功能"></a>4、开启PVE嵌套虚拟化功能</h2><p>通过命令检验嵌套虚拟化功能是否已被开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /sys/module/kvm\_intel/parameters/nested</span><br></pre></td></tr></table></figure>
<p>开启内核支持：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe -r kvm\_intel  </span><br><span class="line">modprobe kvm\_intel nested=1</span><br></pre></td></tr></table></figure>

<p>现在再看看nested是否已开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/module/kvm\_intel/parameters/nested</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>

<p>编辑配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;options kvm\_intel nested=1&quot; &gt;&gt;/etc/modprobe.d/modprobe.conf</span><br></pre></td></tr></table></figure>
<h2 id="5、查看和关闭虚拟机"><a href="#5、查看和关闭虚拟机" class="headerlink" title="5、查看和关闭虚拟机"></a>5、查看和关闭虚拟机</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出所有虚拟机：</span></span><br><span class="line">qm list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭虚拟机：</span></span><br><span class="line">qm stop</span><br></pre></td></tr></table></figure>
<h2 id="6、镜像转换"><a href="#6、镜像转换" class="headerlink" title="6、镜像转换"></a>6、镜像转换</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img convert disk.qcow2 disk.vmdk</span><br></pre></td></tr></table></figure>
<h2 id="7、迁移相关设置"><a href="#7、迁移相关设置" class="headerlink" title="7、迁移相关设置"></a>7、迁移相关设置</h2><p>PVE迁移的类型分加密（secure）或不加密（insecure）<br>secure迁移  </p>
<blockquote>
<p>优点：信息安全，加密迁移<br>缺点：非常耗费host主机的CPU资源，且迁移速度慢  </p>
</blockquote>
<p>insecure迁移  </p>
<blockquote>
<p>优点：迁移速度快，对host主机的资源消耗小<br>缺点：不是加密迁移，信息安全需要考虑  </p>
</blockquote>
<p>如果在网络完全自主可控的情况下，可以考虑insecure迁移</p>
<p>迁移类型在配置文件中设置，web控制台无法设置<br>进入任意host节点—-shell  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@m71:~# cat /etc/pve/datacenter.cfg</span><br><span class="line">keyboard: en-us</span><br><span class="line">migration: network=172.18.171.71/24,type=insecure</span><br><span class="line">type可以设置为 加密secure（默认）不加密insecure</span><br></pre></td></tr></table></figure>

<h2 id="8、问题处理"><a href="#8、问题处理" class="headerlink" title="8、问题处理"></a>8、问题处理</h2><h4 id="8-1、迁移时提示认证失败时"><a href="#8-1、迁移时提示认证失败时" class="headerlink" title="8.1、迁移时提示认证失败时"></a>8.1、迁移时提示认证失败时</h4><blockquote>
<p>Host key verification failed.</p>
</blockquote>
<p>在控制台运行如下  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ssh -e none -o &#x27;HostKeyAlias=pve1&#x27; root@192.168.3.241 /bin/true</span><br><span class="line"></span><br><span class="line">ssh 192.168.3.241</span><br></pre></td></tr></table></figure>
<h4 id="8-2、PVE下qm-stop提示超时的解决办法"><a href="#8-2、PVE下qm-stop提示超时的解决办法" class="headerlink" title="8.2、PVE下qm stop提示超时的解决办法"></a>8.2、PVE下qm stop提示超时的解决办法</h4><blockquote>
<p>TASK ERROR: can’t lock file ‘&#x2F;var&#x2F;lock&#x2F;qemu-server&#x2F;lock-108.conf’ - got timeout</p>
</blockquote>
<p>rm 该文件就可以了。</p>
<ul>
<li><p>先在shell里输入 <code>rm /var/lock/qemu-server/lock-108.conf</code> #108是你的虚拟机编号</p>
</li>
<li><p>再输入<code>qm stop 108</code> 就可以立即关闭你的108号虚拟机了</p>
</li>
</ul>
<h4 id="8-3、虚拟机存放路径"><a href="#8-3、虚拟机存放路径" class="headerlink" title="8.3、虚拟机存放路径"></a>8.3、虚拟机存放路径</h4><blockquote>
<p>iso存放路径： <code>/var/lib/vz/template/iso/</code></p>
</blockquote>
<blockquote>
<p>备份路径： <code>/var/lib/vz/dump/文章地址https://www.yii666.com/blog/469212.html</code></p>
</blockquote>
<blockquote>
<p>local 路径：<code>/var/lib/vz/images/</code></p>
</blockquote>
<blockquote>
<p>local-vm 路径： <code>/dev/pve/</code></p>
</blockquote>
<blockquote>
<p>虚拟机配置文件路径： <code>/etc/pve/</code></p>
</blockquote>
<blockquote>
<p>集群中虚拟机配置文件路径： <code>/etc/pve/nodes/pve（pve为节点名称）/qemu-server/</code></p>
</blockquote>
<h4 id="8-4、本机硬盘格式是lvm，新加硬盘想使用zfs格式，那么请一定要关闭swap。-命令为-swapoff-a-否则zfs会发生很怪异的事情"><a href="#8-4、本机硬盘格式是lvm，新加硬盘想使用zfs格式，那么请一定要关闭swap。-命令为-swapoff-a-否则zfs会发生很怪异的事情" class="headerlink" title="8.4、本机硬盘格式是lvm，新加硬盘想使用zfs格式，那么请一定要关闭swap。 命令为 swapoff -a ,否则zfs会发生很怪异的事情."></a>8.4、本机硬盘格式是lvm，新加硬盘想使用zfs格式，那么请一定要关闭swap。 命令为 <code>swapoff -a</code> ,否则zfs会发生很怪异的事情.</h4><h4 id="8-5、虚拟机出现问题状态为unkonw的解决方法"><a href="#8-5、虚拟机出现问题状态为unkonw的解决方法" class="headerlink" title="8.5、虚拟机出现问题状态为unkonw的解决方法"></a>8.5、虚拟机出现问题状态为unkonw的解决方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service rrdcached stop </span><br><span class="line"></span><br><span class="line">rm -rf /var/lib/rrdcached/* </span><br><span class="line"></span><br><span class="line">service rrdcached start</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pve</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>pve</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2024/10/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h1><blockquote>
<p>确保一个类只有一个实例，并提供一个全局访问点。单例模式有几种实现方式，每种方式都有其特点和适用场景。</p>
<p>适用于需要频繁实例化然后销毁的对象，创建对象消耗资源过多，但又经常用到的对象，频繁访问数据库或文件的对象。</p>
<p>其本质就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。</p>
<ul>
<li>特性和功能：确保一个类只有一个实例，并提供一个全局访问点。</li>
<li>使用环境：当类只需要一个实例，且易于访问，且实例应在整个应用程序中共享时。</li>
<li>注意事项：需要注意线程安全问题。</li>
<li>优点：可以确保一个类只有一个实例，减少了内存开销。</li>
<li>缺点：没有接口，扩展困难。</li>
</ul>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote>
<p>单例模式通常适用于在整个应用程序中只需要一个实例化对象的场景，以确保资源的高效利用和应用程序的稳定性。（共享资源）</p>
<p>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。</p>
<p>控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>
<ul>
<li>日志系统：在应用程序中，通常只需要一个日志系统，以避免在多个地方创建多个日志对象。这一般是由于共享的日志文件一直处于打开状态，所以只能有一个实例去操作，否则内容不好追加也有可能造成资源占用加剧资源消耗。</li>
<li>数据库连接池：在应用程序中，数据库连接池是一个非常重要的资源，单例模式可以确保在应用程序中只有一个数据库连接池实例，避免资源浪费。主要是节省打开或者关闭数据库连接所引起的效率损耗，因为何用单例模式来维护，就可以大大降低这种损耗。</li>
<li>配置文件管理器：在应用程序中，通常只需要一个配置文件管理器来管理应用程序的配置文件，单例模式可以确保在整个应用程序中只有一个配置文件管理器实例。这个是由于配置文件是共享的资源。</li>
<li>缓存系统：在应用程序中，缓存系统是一个重要的组件，单例模式可以确保在整个应用程序中只有一个缓存实例，以提高应用程序的性能。</li>
<li>网站在线人数统计：其实就是全局计数器，也就是说所有用户在相同的时刻获取到的在线人数数量都是一致的。</li>
<li>GUI组件：在图形用户界面(GUI)开发中，单例模式可以确保在整个应用程序中只有一个GUI组件实例，以确保用户界面的一致性和稳定性。</li>
</ul>
</blockquote>
<h3 id="1-懒汉式（线程不安全）"><a href="#1-懒汉式（线程不安全）" class="headerlink" title="1. 懒汉式（线程不安全）"></a>1. 懒汉式（线程不安全）</h3><blockquote>
<p>这是最基本的单例实现，但是它在多线程环境下不是线程安全的。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-懒汉式（线程安全）"><a href="#2-懒汉式（线程安全）" class="headerlink" title="2. 懒汉式（线程安全）"></a>2. 懒汉式（线程安全）</h3><blockquote>
<p>通过锁定机制确保线程安全, 但是有性能消耗。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObject = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (lockObject)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-懒汉式-双重检查锁定（Double-Checked-Locking）"><a href="#3-懒汉式-双重检查锁定（Double-Checked-Locking）" class="headerlink" title="3. 懒汉式 - 双重检查锁定（Double-Checked Locking）"></a>3. 懒汉式 - 双重检查锁定（Double-Checked Locking）</h3><blockquote>
<p>使用双重检查锁定来减少锁定的开销。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObject = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObject)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-饿汉式"><a href="#4-饿汉式" class="headerlink" title="4. 饿汉式"></a>4. 饿汉式</h3><blockquote>
<p>在类加载时就创建实例，简单且线程安全，但是不管是否使用都进行实例化。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用-Lazy-lt-T-gt"><a href="#5-使用-Lazy-lt-T-gt" class="headerlink" title="5. 使用 Lazy&lt;T&gt;"></a>5. 使用 <code>Lazy&lt;T&gt;</code></h3><blockquote>
<p>利用 <code>Lazy&lt;T&gt;</code> 类型来实现线程安全的懒加载。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;Singleton&gt; lazyInstance = </span><br><span class="line">        <span class="keyword">new</span> Lazy&lt;Singleton&gt;(() =&gt; <span class="keyword">new</span> Singleton());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> lazyInstance.Value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>单例模式的使用需要根据应用场景来决定，例如在多线程环境下，需要确保线程安全。</li>
<li>单例模式可能会隐藏类之间的依赖关系，使得单元测试变得困难。</li>
<li>在使用单例模式时，需要考虑单例对象的生命周期和资源管理问题。</li>
</ul>
<p>选择哪种单例实现方式取决于具体需求和上下文环境。在实际开发中，推荐使用 <code>Lazy&lt;T&gt;</code> 方式，因为它简洁、线程安全，并且能够实现延迟加载。</p>
]]></content>
      <categories>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2024/09/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="CPU寄存器"><a href="#CPU寄存器" class="headerlink" title="CPU寄存器"></a>CPU寄存器</h2><p>CPU寄存器是CPU内部用来存放数据的一些小型存储区域，暂时存放参与运算的数据和运算的结果以及一些CPU运行所需要的信息。</p>
<h2 id="原生线程-x2F-托管线程"><a href="#原生线程-x2F-托管线程" class="headerlink" title="原生线程&#x2F;托管线程"></a>原生线程&#x2F;托管线程</h2><blockquote>
<p>原生线程是操作系统管理的线程。CPU都有逻辑核心，每个核心都有多个寄存器，每一个逻辑核心都 会根据程序的寄存器从内存中去读取指令，单个逻辑核心在同一时间只能执行一段机器码，机器码就 是某个任务的处理内容，单个逻辑核心在同一时间只能执行一个线程，那么需要多个线程同时运行的 效果，就需要在这个逻辑核心上去轮流运行，并且每一个线程只能够运行一段很短的时间，然后就形 成了多线程的效果，其中轮流运行就是线程切换。</p>
</blockquote>
<blockquote>
<p>托管线程是基于原生线程创建的线程模型，是由.NET管理的线程。一个托管线程只能运行一个原生线 程。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/d31c086c1a3b4b04a62d14e30677e30c.png" alt="d31c086c1a3b4b04a62d14e30677e30c.png"></p>
<h2 id="主动切换-x2F-被动切换-x2F-上下文-x2F-上下文切换-x2F-线程调度-x2F-栈空间"><a href="#主动切换-x2F-被动切换-x2F-上下文-x2F-上下文切换-x2F-线程调度-x2F-栈空间" class="headerlink" title="主动切换&#x2F;被动切换&#x2F;上下文&#x2F;上下文切换&#x2F;线程调度&#x2F;栈空间"></a>主动切换&#x2F;被动切换&#x2F;上下文&#x2F;上下文切换&#x2F;线程调度&#x2F;栈空间</h2><blockquote>
<p>主动切换是线程对应的任务主动要求暂停线程，比如说线程锁被其它线程获取了，这时候任务会主动 要求暂停线程，一直到锁释放才继续。如果读取文件时要等待磁盘的响应，那么这个任务也会要求去 暂停线程的运行。</p>
</blockquote>
<blockquote>
<p>被动切换是线程运行超过了一定时间后，操作系统会强制切换到下一个线程，这种强制切换的模式叫 做抢占模式，线程在抢占之前被运行的最大时间叫做时间片，这种抢占机制是基于硬件计时器来实现的。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/65ad400628354af3889863f2efab1091.png" alt="65ad400628354af3889863f2efab1091.png"></p>
<blockquote>
<p>上下文是CPU中各个寄存器的值。<br>上下文切换是线程之间的切换。本质上其实就是保存了当前寄存器的值到切换前的线程关联的上下文 数据中，然后从切换后的线程关联的上下文数据中读取值到寄存器中。</p>
</blockquote>
<blockquote>
<p>线程调度是负责安排待运行队列中的线程在逻辑核心上轮流执行，把等待不可用资源的线程放入到资 源对应的等待线程队列中，当资源可用后，再把等待的线程放入到线程队列。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/3d1ecca0a9c44110aced8f136a90e15b.png" alt="3d1ecca0a9c44110aced8f136a90e15b.png"></p>
<blockquote>
<p>栈空间是每一个原生线程都需要在内存中去使用的一块空间。栈空间主要用途就是用来保存函数使用 的数据，比如参数，本地变量，地址等等。栈空间最大地址称为栈底，最小地址称为栈边界，最后一 个被添加到栈的元素的所在地址，叫做栈顶。栈顶的地址是保存在栈寄存器中的也就是RSP寄存器， 如果是X86就是ESP。栈底和栈边界的地址保存在操作系统管理的原生线程对象中。由于栈寄存器属 于上下文的一部分，在上下文切换的时候这个上下文也会被同时切换。<br>栈空间存储自己的数据。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/18bd202362904604a54fed10dc31cf3b.png" alt="18bd202362904604a54fed10dc31cf3b.png"></p>
<blockquote>
<p>抢占模式&#x2F;合作模式<br>处于抢占模式的线程不能访问托管堆上面的对象，必须等待GC结束，切换到合作模式。<br>处于合作模式的线程可以自由访问托管堆上面的对象。<br>托管代码都是在合作模式下的，非托管代码是没有这个限制的。<br>一旦进入抢占模式，托管代码就会停止运行，非托管代码会继续运行但是只能做和.NET对象无关的处理。</p>
</blockquote>
<blockquote>
<p>为什么要有抢占模式和合作模式<br>GC要找出所有存活的对象，清理没有引用的对象。负责执行扫描与清理对象的GC线程和负责分配对 象或者改变对象引用关系的其它线程同时运行，如果GC线程在清理一个没有引用的对象，那么正好这 个时候有一个线程去改变这个引用对象，就会发生冲突。<br>所以在GC运行的过程中，需要停止其它线程的运行，以保证对象间引用关系在GC的运行中不会改变。 但是以这种粗暴的方式来停止线程会带来很多问题。比如某个线程获取了某一个.NET运行时内部线程 锁后变成了停止状态，然后GC线程再处理过程中需要获取同一个锁，那么这时候就会导致死锁发 生。.NET为了让线程可以更安全的配合GC工作，就引用了抢占模式和合作模式。GC会根据需要去切 换到不同的模式。<br>GC在停止其它线程运行的过程就是GC在切换某个线程到抢占模式。<br>GC恢复某个线程运行的过程就是GC在切换某个线程到合作模式。</p>
</blockquote>
<blockquote>
<p>GC安全点<br>JIT编译器在生成托管函数汇编代码的时候会同时生成元数据，这个元数据中包含了GC信息，这个GC信息中包含了某个线程运行到某条指令时哪些位置有引用类型的对象，这些对象会作为根对象扫描。因为包含的引用类型对象位置在运行的过程中可能会不断的改变，如果要针对每一条汇编指令都生产一条GC信息会消耗很多的资源，所以JIT编译器在生产GC信息的时候是部分选择生成，这些被挑选的部分就是GC安全点。如果有一个托管函数的指令都生成了GC安全点，那么这个函数就称为完全可中断函数，如果不是每一条指令都生成GC安全点那么这个函数就称为部分可中断函数。</p>
</blockquote>
<blockquote>
<p>线程本地存储<br>线程本地存储是用于实现按线程隔离的线程本地变量。<br>对于同一个线程的本地变量，各个线程都有独立的值，修改的值只对修改的线程可见。<br>相当于让每个线程都开辟了一块内存空间，用来存储共享变量的一个副本，然后每个线程只需要去访 问和操作自己的共享变量副本就可以了，从而避免了多线程去竞争同一个共享资源。<br>ThreadStatic<br>ThreadStatic特性会让变量变成线程本地存储变量，每一个线程输出的结果不会被其它线程影响。</p>
</blockquote>
<blockquote>
<p>IOC容器里面的线程单例生命周期就是用ThreadStatic实现的。</p>
</blockquote>
<blockquote>
<p>ThreadLocal<br>ThreadLocal是一个包装类和ThreadStatic是完全等价的。<br>ThreadLocal中每个托管线程对象都关联一个TLB(Thread Local Block)表，这个表以AppDomain ID作为 索引保存TLM(Thread Local Module)表。<br>TLB表以模块ID为索引保存了托管线程本地存储空间的开始地址。<br>当.NET运行时在加载一个程序集的时候，会枚举程序集中的模块和模块中的全局变量，然后根据其是 否为线程本地变量分为两个部分，非线程本地变量保存在AppDoamin高频堆中，线程本地变量就只计 算偏移值，存储空间会在首次访问的时候分配。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/07710a829d8146a49c5bd22854ddcec0.png" alt="07710a829d8146a49c5bd22854ddcec0.png"></p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><blockquote>
<p>.NET中原子操作就是要么成功且状态改变，要么失败且状态不变。<br>比如用多线程处理不同文件，并且需要实时输出当前处理完成的数量合计，定义一个整数类型的全局 变量，每一个线程每处理完一个文件就递增一次，然后定时输出这个全局变量的值，这个递增的操作 必须是原子操作。<br>InterLocked<br>InterLocked类提供了执行原子操作的一些方法，这些方法接收的是引用参数也就是变量的内存地址，针对内存地址中的值进行原子操作。</p>
</blockquote>
<h2 id="线程锁-x2F-无锁算法"><a href="#线程锁-x2F-无锁算法" class="headerlink" title="线程锁&#x2F;无锁算法"></a>线程锁&#x2F;无锁算法</h2><blockquote>
<p>线程锁是把指定区域内的操作都变成原子操作，具有很高的通用性。线程锁只有获取锁和释 放锁，在 获取锁之后和释放锁之前的中间部分只保证只有一个线程运行。<br>无锁算法是不使用线程锁，而是修改操作的内容，以满足修改操作的条件。</p>
</blockquote>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote>
<p>自旋锁是基于原子操作实现的，基于一个数值来表示锁是否被获取，比如0表示未被获取，1表示已 被获取。获取锁的时候会先使用原子操作去设置它的数值为1，然后去检查修改前的数值是否为0，如 果为1表示获取成功，否则一直重试直到成功为止。释放锁的时候会设置它为0，其它正在获取锁的 线程再下一次重试时才会成功获取。<br>自旋锁指当一个线程再获取锁的时候，如果锁已经被其它线程获取，那么这个线程将循环等待，不断 的判断锁是不是能被成功获取，直到成功获取到了锁，才会退出循环。<br>如果已经明确的知道了被锁住的代码执行的时间非常短，就可以选择开销比较小的自旋锁。<br>SpinWait&#x2F;SpinOnce<br>Thread里面的SpinWait方法可以实现一个自旋锁。SpinWait通过调用汇编指令pause告诉CPU当前正 在自旋锁的循环中，当前的逻辑核心就可以按照时钟周期得到一个休息然后再去执行下一条指令，由 于pause指令休息时间在不同的CPU型号中是不同的，所以在.NET中自定义了一个标准的休息时间， 在程序启动时会计算需要多少次调用指令才能接近这个标准时间，SpinWait函数就会根据计 算出来的 次数去调用这个指令，这样就会让所有平台上的CPU休息时间是保持一致的。<br>SpinWait类也可以实现一个自旋锁。调用SpinWait类的SpinOnce方法实现等待。如果在一定次数以内， 并且当前环境的逻辑核心数&gt;1，那么底层还是调用的Thread.SpintWait方法。如果超过了一定次数，并 且当前环境的逻辑核心&#x3D;1，那么就会交替使用Thread.Sleep(0)和Thread.Yield方法，再超过一定次数会 使用Thread.Sleep(1),让线程休眠1毫秒以避免频繁占用CPU资源，SpinWait类的这种特点可以解决自 选锁保护着代码长时间运行的问题，SpinWait类会告诉操作系统切换到其它线程上，让当前线程进入 休眠状态，这样就不会一直执行SpintWait方法而导致CPU在线程被抢占之前无法执行其它工作。 Sleep(0)实际上是调用SleepEx系统函数，Yield是调用SwitchToThread的系统函数，SwitchToThread函 数只会切换当前逻辑核心关联的待运行队列中的线程，是不会切换到其它逻辑核心上关联的线程，而 SleepEx是可以切换到任意逻辑核心关联的待运行队列中的线程，并且让当前线程在指定时间内无法重 新进入待运行队列。<br>SpinLock类也可以实现自旋锁，这个类封装了锁状态的管理，以及调用SpinOnce的方法。<br>自旋锁保护的代码应该在较短的时间内执行完毕，如果代码长时间运行，就会造成某一个线程持有锁 的时间过长，就会导致其它等待获取锁的线程不断的重试并且占用逻辑核心，如果使用不当会造成CPU 的使用率非常高。<br>自旋锁是不公平的锁，不公平是因为等待时间最长的线程不一定会持有锁， 这就会造成线程饥饿。<br>自旋锁不会使线程状态发生切换，不会使线程进入阻塞状态，减少了不需要的上下文切换。</p>
</blockquote>
<blockquote>
<p>线程饥饿<br>多个线程同时访问一个同步资源，有些线程总是没机会获得锁。</p>
</blockquote>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><blockquote>
<p>自旋锁不适用于长时间运行的操作，应用场景比较有限。更通用的是操作系统提供的基于原子操作和线程调度结合实现的互斥锁。操作系统提供的互斥锁也有一个数值来表示这个锁是否已经被获取。与自旋锁不同的是互斥锁当获取锁失败的时候不重试，而是安排获取锁线程进入等待，把线程对象添加到这个锁关联的队列中，另一个线程锁释放的时候会检查这个队列是不是有线程对象，如果有就通知操作系统去唤醒这个线程。处于等待状态的线程是没有在运行的，即使这个锁长时间不释放也不会消耗CPU的资源。线程要从等待状态唤醒，唤醒之后还要调度运行，这个时候从等待状态到调度运行中间要花费一些时间，这个时间与自旋锁重试所需的比率是相当的，自旋锁如果是纳秒级，互斥锁就是毫秒级。</p>
</blockquote>
<blockquote>
<p>Mutex<br>Mutex包装了操作系统提供的互斥锁。<br>Mutex支持跨进程使用，可以防止程序多开，也可以用于保护多个进程共享的资源。</p>
</blockquote>
<h4 id="混合锁"><a href="#混合锁" class="headerlink" title="混合锁"></a>混合锁</h4><blockquote>
<p>由于互斥锁的性能比较低，.NET提供了更通用性能也更好的混合锁，而且任何引用类型的对象都可以 作为这个锁对象，也不需要事先创建某一个类型的实例，并且涉及非托管资源还会由.NET运行时自 动释放。<br>混合锁在获取锁失败后，也会向自旋锁一样重试一定的次数，超过一定的次数，进入等待状态。<br>混合锁的好处就是第一次获取锁失败以后，如果其它线程又马上释放了锁，那么当前这个线程在下一 轮重试时就可以立即获取成功，这样就不需要经过一个耗时的线程调度去处理。如果其它线程在短时 间内没有释放锁，某个线程获取锁的时候重试超过一定的次数，就会进入等待状态，避免消耗CPU 的资源。<br>混合锁适用于大部分的场景。<br>Monitor&#x2F;Lock<br>Monitor和Lock是完全等价的。</p>
</blockquote>
<blockquote>
<p>为什么加锁用引用类型，并且定义为静态只读？<br>引用类型定义为静态是为了让对象常驻内存，定义为只读readonly是为了让引用类型在声明时就完成 初始化，并且保证对象的不可变性，这样在高并发的场景下，多线程在任何时候都看到的是同一个对 象。定义为私有成员保证该引用类型不会受到其它地方的影响。<br>定义为引用类型还有一个原因就是因为任何一个引用类型的对象都有一个对象头，对象头中是可以存 储当前获取锁的一个线程ID和进入次数，还可以存储同步块索引，同步块包含了所属线程对象，进入 次数，事件对象等。<br>事件对象可以让线程进入等待状态和唤醒线程，同步块可以按照需要创建并自动释放。<br>为什么加锁不能用string？<br>因为string是一个特殊的引用类型，具有不变性和字符串驻留。<br>整个程序中任何字符串都只有一个实例，因此只要在程序中的任何位置加锁具有相同内容的字符串， 就会锁定程序中该字符串的所有实例。<br>说的更直白点，我就是想锁这一块儿的内容，结果把所有跟该字符串内容相同的区域都锁了。</p>
</blockquote>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><blockquote>
<p>读写锁适用于频繁读取，并且读取需要一定时间的场景，尤其是所谓的共享资源。共享资源的读取操 作通常是可以同时执行的，而普通的互斥锁，不管是读取还是修改都是无法同时执行的。如果说多个 线程为了读取操作而去获取一个互斥锁，那么同一时间只有一个线程可以执行读取操作，在频繁读取 的情况下，就会对吞吐量造成影响。<br>多线程写入同一个文件，会经常发生文件被占用而且无法访问的可能，如果不使用读写锁，而使用多 线程写入文件就会失败很多次，使用读写锁之后就可以确保每个线程都可以完成写入操作。<br>读写锁的本质上也是一个混合锁。<br>ReaderWriterLock<br>读写锁：ReaderWriterLockSlim，不同的ReaderWriterLockSlim对象中锁定同一个文件也会被视为不同 的锁进行管理，这种差异可能会再次导致文件的并发写入问题，所以ReaderWriterLockSlim应尽量定 义为只读的静态对象。<br>ReaderWriterLockSlim类似于ReaderWriterLock但简化了递归规则以及升级和降级锁定状态的规则，可 避免多种潜在的死锁情况，性能明显优于ReaderWriterLock。<br>ReaderWriterLock:用于同步资源访问，允许多线程同时进行读访问，或者单线程写访问，在资源不 经常发生更改的情况下，吞吐量比简单的一次只允许一个线程的锁更高。<br>EnterWriteLock:进入写入状态，调用线程进入锁定状态之前一直处于阻塞状态。<br>TryEnterWriteLock:进入写入状态，可指定阻塞的间隔时间，调用线程在间隔期间并未进入写入模式返 回false。<br>ExitWriteLock:退出写入状态，应使用finally块执行ExitWriteLock方法，确保调用方退出写入模式。</p>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><blockquote>
<p>信号量是一个具有特殊用途的线程同步对象。<br>信号量内部使用一个数值来记录可用的数量，每一个线程都可以通过增加这个数量和减少这个数量进 行同步。<br>在执行减少数量的时候如果减少的数量&gt;现有数量，线程就会进入等待状态，一直到其它的线程去增加 这个数量，并且这个数量不少于减小的数量为止。<br>比如学校的自习室：互斥锁管理的是某个座位是否被占用，信号量管理的是整个自习室中未被占用的 座位数量，每当有人占用一个座位，这个自习室中的座位就会减少，当有人离开这个自习室座位就会 增加。如果信号量为0那就说明所有的座位都被占用了，那么新来的人就需要等待。<br>互斥锁是谁获取这个锁谁就负责释放这个锁。信号量的增加和减少的线程可以是不同的。<br>信号量最常见的场景就是实现生产消费模式，生产消费模式一般是一个队列，有一部分线程向队列里 面添加任务，另一部分线程从队列里面取出任务并处理。<br>Semaphore&#x2F;SemaphoreSlim<br>SemaphoreSlim是阉割版的，不支持跨进程。</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote>
<p>在多线程环境下，一个被volatile修饰的变量，其值被多线程读写时永远操作的是最新的值，在多线程环境下的操作保证了值的一致性。</p>
</blockquote>
<blockquote>
<p>原理<br>多线程同时访问一个变量，CLR为了效率，允许每个线程进行本地缓存，导致了变量的不一致性。<br>volatile修饰的变量，不允许线程进行本地缓存，每个线程的读写都是直接操作在共享内存上，写操作 可以保证写到共享内存上，读操作也能保证从共享内存上读到最新的值，这就能保证变量始终具有一 致性。</p>
</blockquote>
<blockquote>
<p>作用<br>volatile关键字有两个作用。<br>第一个可以保证在多线程环境下共享变量的可见性。<br>第二个是可以通过增加内存屏障，去防止多个指令之间的一个重排序。<br>可见性是指当一个线程对于共享变量的修改，其它线程可以立刻看到修改之后的一个值。<br>可见性的问题本质上是由几个方面来造成的。<br>首先是CPU层面的高速缓存，在CPU里面设计了三级缓存去解决CPU运算效率和内存IO效率的问题， 但是它也带来了缓存一致性的问题。<br>而在多线程并行执行的情况下，缓存一致性问题就会导致可见性问题。<br>所以对于volatile关键字修饰的共享变量，CLR会自动增加一个#Lock汇编指令。<br>而这个指令会去根据不同的CPU型号，去自动添加总线锁，或者缓存锁。<br>总线锁，锁定的是CPU的前端总线，从而去导致在同一个时刻，只能有一个线程和内存通信，这样就 能避免多线程并发造成的可见性问题。<br>缓存锁，是对总线锁的一个优化，因为总线锁导致CPU的使用效率大幅度下降。所以缓存锁，只针对 于CPU三级缓存中的目标数据去加锁，缓存锁是使用MESI缓存一致性协议来实现的。<br>指令重排序的问题，就是说指令在编写的数据和执行的顺序是不一致的，从而在多线程环境下导致可 见性的问题。<br>指令重排序本质上是一种性能优化的手段，它来自于几个方面。<br>首先是CPU层面，针对于MESI协议的更进一步的优化，去提升CPU的一个利用率，所以它引入了一 个叫StoreBuffer的一个机制，而这种优化机制，会导致CPU的乱序执行。<br>为了避免这样的问题，CPU提供了内存屏障指令，上层应用可以在合适的地方去插入内存屏障，去避 免CPU指令重排序的一个问题。<br>还有编译器层面的优化，编译器在编译的过程中，在不改变单线程语义和程序正确性的前提下，对指 令进行合理的重排序，从而去优化整体的一个性能。<br>所以，对于共享变量增加volatile关键字，编译器层面就不会去触发编译器的优化，同时在CLR里面， 它会去插入内存屏障指令，来避免重排序的问题。</p>
</blockquote>
<h2 id="后台线程-x2F-前台线程"><a href="#后台线程-x2F-前台线程" class="headerlink" title="后台线程&#x2F;前台线程"></a>后台线程&#x2F;前台线程</h2><blockquote>
<p>后台线程，进程结束，线程结束。<br>前台线程，任务结束，线程结束。</p>
</blockquote>
<blockquote>
<p>Thread里面Sleep和Join的区别<br>Sleep是主线程自己阻塞自己，Join是子线程阻塞主线程。</p>
</blockquote>
<h2 id="Thred-x2F-TreadPool"><a href="#Thred-x2F-TreadPool" class="headerlink" title="Thred&#x2F;TreadPool"></a>Thred&#x2F;TreadPool</h2><blockquote>
<p>ThreadPool其实就是Tread的集合，在任务多的时候全局队列会存在竞争而消耗资源。<br>Thread默认是前台线程。<br>ThreadPool没有很好的API区域控制，如果线程执行无响应就只能等待结束，从而产生Task。</p>
</blockquote>
<h2 id="如何理解线程安全"><a href="#如何理解线程安全" class="headerlink" title="如何理解线程安全"></a>如何理解线程安全</h2><blockquote>
<p>在多个线程去访问某个方法或者对象的时候，不管通过任何方式的调用，或者线程如何去交替执行。<br>在程序中，不做任何同步干预的情况下，这个方法或者对象的执行，都能够按照预期的结果 来返回。<br>那么这个类，就是线程安全的。<br>线程安全问题的具体表现主要就是原子性。<br>原子性就是一个线程执行一系列程序指令操作的时候，它应该是不可中断的。<br>因为一旦出现了中断，站在多线程的角度来看，这一系列的程序指令，会出现前后执行结果不一致的 问题。这个和数据库里面的原子性是一样的。</p>
</blockquote>
<h2 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h2><blockquote>
<p>线程锁：Lock不能用string，如果声明的两个string内容一样，会形成死锁。<br>可以用Lock加锁，保证线程安全。<br>可以用.Net框架提供的线程安全的集合来保证线程安全。<br>线程取消<br>CancellationTokenSource</p>
</blockquote>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><blockquote>
<p>SynchronizationContext表示线程上下文，实现一个线程和另外一个线程的通讯。</p>
</blockquote>
<blockquote>
<p>Send:当前线程上去调用委托实现，同步调用。子线程上直接调用UI线程执行，等UI线程执行完子线 程才执行。</p>
</blockquote>
<blockquote>
<p>Post:在线程池上去调用委托实现，异步调用。子线程会从线程池中找出一个线程去调UI线程，子线程 不等的UI线程的完成而直接执行自己的逻辑。</p>
</blockquote>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><blockquote>
<p>异步操作是执行某项操作后不等待结束，但是可以在操作结束后收到通知。</p>
</blockquote>
<blockquote>
<p>一个线程的栈空间，默认会分配8-10M的空间，栈空间是在内存里的，太多的线程就会让内存不足。<br>线程的创建都是需要消耗内存空间的，每创建一个栈空间都会产生内存的开销，当内存的使用超过了 物理内存的时候，那么一部分的数据就会放到磁盘上，随之而来的就是性能大幅度下降。<br>而且太多的线程也会让操作系统去调度线程所花费的时间变长，会导致性能下降。</p>
</blockquote>
<blockquote>
<p>解决这个问题的方法之一就是事件循环机制。</p>
</blockquote>
<blockquote>
<p>事件循环机制就是程序使用一个或多个线程专门用于捕获对象的检查状态，把执行的阻塞操作换成非 阻塞操作，然后再去注册事件能在处理完成后收到通知。<br>JS是单线程的，JS中的异步就是使用事件循环机制来实现的，比如DOM事件，ajax，axios都是异步 事件。这种做法就避免了同时执行阻塞操作而需要多个线程执行的问题，但是这种事件循环机制的 代码难度非常高，所以提供了一些基于回调 的异步操作，在执行异步操作的时候在执行一个非阻塞操 作，然后注册事件，关联回调，能让接收事件之后，自动关联之前的回调。</p>
</blockquote>
<blockquote>
<p>.NET中的异步编程模型在windows上就是基于IOCP来实现的，IOCP简单来说就是一组支持多个同时 发生的异步IO操作接口。在Linux上是基于Epoll模型来实现的，Epoll模型就是一个多路复用的IO接 口。</p>
</blockquote>
<blockquote>
<p>由于基于回调的这个异步编程模型的通用性不强，.NET在其基础之上又封装了一层，以任务也就是Task 为基础的接口，也就是任务并行库TPL，TPL最大的特点就是分离了执行异步操作与注册回调的处理， 这样一来就可以让任何异步操作都具有相同的方法注册回调，等待结束和处理错误，为之后的aysnc 和await打下了一个基础。</p>
</blockquote>
<blockquote>
<p>Task类型就是表示执行了一个异步的方法。<br>如果使用Task类型作为返回结果去创建100个Task对象，而Task类型又是个引用类型，那么创建对 象的时候就会从托管堆中去分配内存，创建过多的引用类型对象又会频繁的触发GC，从而影响程序的 执行性能，那为了减少这种场景下的性能消耗，在.NET里面还提供了一个ValueTask类型。它实际上是 一个Task类型的包装类，是个值类型，创建它的时候是不需要从托管堆中分配内存的。如果异步操作 可以同步完成，这个时候就可以选择一个叫做ValueTask的类型，回调可以立刻被调用，并且没有任何 额外的开销。</p>
</blockquote>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Task类型就是表示执行了一个异步的方法。<br>如果使用Task类型作为返回结果去创建100个Task对象，而Task类型又是个引用类型，那么创建对 象的时候就会从托管堆中去分配内存，创建过多的引用类型对象又会频繁的触发GC，从而影响程序的 执行性能，那为了减少这种场景下的性能消耗，在.NET里面还提供了一个ValueTask类型。它实际上 是一个Task类型的包装类，是个值类型，创建它的时候是不需要从托管堆中分配内存的。如果异步操 作可以同步完成，这个时候就可以选择一个叫做ValueTask的类型，回调可以立刻被调用，并且没有任 何额外的开销。</p>
<p>Task.Wait():就是等待任务执行完成，Task状态变为Completed。<br>Task.WaitAll():等待所有任务完成。<br>Task.WaitAny():等待任何一个任务完成就继续向下执行。<br>Task.ContinueWith():第一个Task完成后自动启动下一个Task，进行Task的延续。</p>
<p>Task.Run&#x2F;Task.Factory.StartNew<br>Task.Run就是简单的将工作交给线程池处理。<br>Task.Run的参数TaskScheduler取的是默认对象Default。<br>TaskScheduler可以用来控制任务的调度和运行。<br>Task.Factory.StartNew可以做到更精细的控制。<br>TaskCreationOptions可以用来控制任务的行为。</p>
<h3 id="Thread-x2F-ThreadPool-x2F-Task-x2F-Parallel"><a href="#Thread-x2F-ThreadPool-x2F-Task-x2F-Parallel" class="headerlink" title="Thread&#x2F;ThreadPool&#x2F;Task&#x2F;Parallel"></a>Thread&#x2F;ThreadPool&#x2F;Task&#x2F;Parallel</h3><blockquote>
<p>Tread的优点在于提供了丰富的多线程操作API，缺点在于线程的个数使用不加以限制，以及无法复用 线程，因此推出了TreadPool技术。</p>
</blockquote>
<blockquote>
<p>TreadPool的优点在于解决了线程的个数限制以及线程的复用，缺点在于API较少而且线程的等待问题 解决起来较为麻烦，所以推出了Task。</p>
</blockquote>
<blockquote>
<p>Task的优点在于丰富的API，以及多线程的方便管理，缺点在于线程的数量控制起来较为麻烦，因此推 出了Parallel技术。</p>
</blockquote>
<blockquote>
<p>Parallel的优点在于丰富的API，多线程方便管理，线程的数量控制起来比较简单，但是主线程也会参 与计算，导致主线程的阻塞，但是这个问题可以用Task.Run来包一层解决。</p>
</blockquote>
<h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><blockquote>
<p>多线程进行并行迭代</p>
</blockquote>
<h4 id="TreadPool"><a href="#TreadPool" class="headerlink" title="TreadPool"></a>TreadPool</h4><blockquote>
<p>不断的开启线程和销毁，存在很大开销，池化思想，用完放回线程池，不销毁，享元模式。</p>
</blockquote>
<blockquote>
<p>线程池还可以控制线程总数量。ManualResetEvent</p>
</blockquote>
<blockquote>
<p>TreadPool线程式开关：ManualResetEvent</p>
</blockquote>
<h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><blockquote>
<p>用async和await这两个组合可以简化异步方法的编写。</p>
</blockquote>
<blockquote>
<p>如果主线程遇到了await关键字，主线程就会回来执行自己的逻辑，await等待的任务是新开启线程的 执行，await后面的代码等到新开启线程的任务执行完毕以后再执行。</p>
</blockquote>
<blockquote>
<p>所以用async和await这组关键字，它是不阻塞主线程的。</p>
</blockquote>
<blockquote>
<p>异步的性能实际上比多线程要高，异步内部使用的是线程池，池里面的线程基本上都处于激活状态， 它不会反复的去造成多次的线程切换，线程切换消耗的性能主要是上下文的切换，上下文的切换主要 就是唤醒和等待，这两个切换是比较消耗资源的，但是在线程池里面的线程都是属于唤醒状态的, 所 以这个时候是没有什么性能消耗的。所以说现在能用异步就用异步，无脑异步。</p>
</blockquote>
<blockquote>
<p>async&#x2F;await会创建新的线程吗?<br>不会。aync&#x2F;await关键字本身不会创建新的线程，await的方法内部一般会创建新的线程。</p>
</blockquote>
<blockquote>
<p>MVC&#x2F;WebAPI中的Action中使用aync&#x2F;await会提高请求的响应速度吗？<br>不会。<br>Web应用本身就是多线程模式，服务器会为每个HTTP的请求分配工作线程。<br>使用同步方法时，线程会被耗时操作一直占有，直到耗时操作完成。<br>使用异步方法时，程序走到await关键字时会立即return，释放当前的线程，余下的代码会进入到一个 回调中，耗时操作完成时才会触发回调去执行。<br>像磁盘的IO或者网络的IO，如果有耗时操作时才考虑使用异步操作。<br>async和await这组关键字，它也不能提升HTTP请求的响应速度，但是可以提升HTTP请求的响应能力 (吞吐量)。</p>
</blockquote>
<h4 id="async-x2F-await原理"><a href="#async-x2F-await原理" class="headerlink" title="async&#x2F;await原理"></a>async&#x2F;await原理</h4><blockquote>
<p>跟同步方法相比，CLR在执行异步方法的时候，它有几个不同的特点。<br>异步方法它并不是一次性就执行完成的，而是分了多次执行才完成的。<br>而且异步方法也不是由同一个线程来完成执行的，而是从线程池里面每次动态分配一个线程来执行。<br>所以结合异步方法的这些执行特点，C#编译器会将异步方法转换成一个状态机的结构。这种结构它能 进行挂起和恢复。<br>而且它的执行方式也是一种工作流的方式。</p>
</blockquote>
<h4 id="async-x2F-awati执行步骤"><a href="#async-x2F-awati执行步骤" class="headerlink" title="async&#x2F;awati执行步骤"></a>async&#x2F;awati执行步骤</h4><blockquote>
<p>CLR会创建了一个状态机，这个状态机的操作数默认值是-1。<br>然后开始执行状态机。<br>状态机通过这个操作数来选择执行的路径。<br>状态机调用GetAwaiter方法来获取一个等待的对象awaiter，它的类型是TaskAwaiter。<br>状态机在获取awaiter对象之后，会查询awaiter对象的IsCompleted属性。<br>如果IsCompleted属性为True，那么操作就会以同步的方式来执行。<br>如果IsCompleted属性为False，那么操作就会以异步的方式来执行，然后状态机会调用awaiter对象的 OnCompleted方法并给它传递一个委托。<br>这个时候状态机就会允许当前线程返回到原来的地方去执行后面的代码。<br>然后在将来的某个时候，awaiter对象会在完成时调用当时给OnCompleted方法传递的委托然后执行 MoveNext方法，这个时候就可以根据状态机中的某个字段来知道如何到达代码中正确的位置，使方法 能够从当初离开的位置继续执行。<br>最后会调用awaiter对象的GetResult方法获取最终的结果。</p>
</blockquote>
<blockquote>
<p>ConfigureAwait(false)<br>使用await时，在执行完异步任务后，系统会尝试返回之前的线程继续执行。<br>使用ConfigureAwait(false)时，系统会在执行完异步任务后不会尝试返回之前的线程(不捕获线程的上下 文)，而是在线程池里面找一个空闲的线程执行接下来的代码。<br>使用ConfigureAwait(false)在非UI线程执行await任务时非常有用，因为调用异步任务的线程此时可能 正在忙着做其它事情，没有空接着执行后面的代码。</p>
</blockquote>
<h4 id="Invoke-x2F-BeginInvoke"><a href="#Invoke-x2F-BeginInvoke" class="headerlink" title="Invoke&#x2F;BeginInvoke"></a>Invoke&#x2F;BeginInvoke</h4><blockquote>
<p>Invoke调用时，会阻止当前主线程的运行，等待Invoke方法返回时才继续执行后面的代码，类似于同 步执行。<br>BeginInvoke调用时，当前线程会启动线程池中的某个线程来执行方法，BeginInvoke不会阻止当前主线 程的运行，而是等当前主线程做完事情之后再执行BeginInvoke中的代码，类似于异步执行。想获取 BeginInvoke执行完毕后的结果，可以调用EndInvoe方法来获取。</p>
</blockquote>
<h2 id="CPU飙升的原因"><a href="#CPU飙升的原因" class="headerlink" title="CPU飙升的原因"></a>CPU飙升的原因</h2><blockquote>
<p>CPU是整个计算机的核心计算资源。对于一个应用程序来说，CPU的最小执行单元是线程。</p>
</blockquote>
<blockquote>
<p>导致CPU飙升的原因，可能是CPU的上下文切换过多。<br>对CPU来说，同一个时刻下，每个CPU核心只能运行一个线程。<br>如果有多个线程要去被执行，CPU只能通过上下文切换的方式来调度不同的线程。<br>上下文切换需要保存运行中线程的执行状态，还得让处于等待中的线程恢复执行。<br>这两个过程都需要CPU执行内核的相关指令，去实现状态的保存和恢复。<br>如果有较多的上下文切换，就会占据大量的CPU资源。<br>从而使得CPU无法执行用户进程中的真正指令，导致响应速度下降。</p>
</blockquote>
<blockquote>
<p>在C#中，文件IO，网络IO，锁等待，这些都会造成线程的阻塞，导致CPU的上下文切换。<br>还有一种情况就是CPU的资源被过度消耗了，也就是在程序中创建了大量的线程或者有线程一直占据 CPU的资源，无法被释放，比如死循环。</p>
</blockquote>
<blockquote>
<p>CPU的利用率过高，就会导致应用程序中的线程，无法获得CPU的调度，从而影响程序的执行效率。<br>所以可以在任务管理器里面找到CPU利用率较高的进程，然后找到进程中CPU消耗过高的线程。</p>
</blockquote>
<blockquote>
<p>但是这里有两种情况。</p>
</blockquote>
<blockquote>
<p>第一种情况就是CPU利用率过高的线程一直是同一个，也就是线程的ID没有变化，说明在程序中存在 着长期占用CPU没有释放的一个情况，那么这种情况需要把线程的内存地址和线程的ID都记录到日志 文件里面，然后去找出现问题的代码。</p>
</blockquote>
<blockquote>
<p>第二种是CPU利用率过高的线程ID，一直在不断的变化，那么说明线程创建过多，需要去挑选几个线 程的ID，然后去排查。</p>
</blockquote>
<blockquote>
<p>反正就是不好查，有可能定位的结果是程序正常，只是在CPU飙升的那一刻，用户访问量非常大导致 系统的资源不够。<br>像这种情况，就要去增加系统的资源，换性能更高的CPU。</p>
</blockquote>
<h2 id="多线程排错"><a href="#多线程排错" class="headerlink" title="多线程排错"></a>多线程排错</h2><blockquote>
<p>多线程启动无序，执行无序，结果无序，所以哪个线程报错了必须给每个线程包上try catch进行异常 捕获，然后加日志，把线程的内存地址打印出来。<br>如果在visual studio的调试中报错了，可以直接从诊断工具中看是哪个线程报错了，报了什么错，从诊 断工具中点击该异常，visual studio可以激活历史调试。</p>
</blockquote>
<h2 id="吞吐量-x2F-并发量"><a href="#吞吐量-x2F-并发量" class="headerlink" title="吞吐量&#x2F;并发量"></a>吞吐量&#x2F;并发量</h2><blockquote>
<p>吞吐量是指单位时间内的数据总量。并发量是指单位时间内的请求数量。</p>
</blockquote>
<blockquote>
<p>比如一条双行道的公路，只能同时过2辆车，1个小时同行了100辆车。这里的2就是并发量，这里 的100就是吞吐量。</p>
</blockquote>
<h2 id="并行-x2F-并发"><a href="#并行-x2F-并发" class="headerlink" title="并行&#x2F;并发"></a>并行&#x2F;并发</h2><blockquote>
<p>并行和并发最早描述的是在C#并发编程里面的一个概念，强调的是CPU处理任务的一个能力。</p>
</blockquote>
<blockquote>
<p>并发就是同一个时刻CPU能够处理的任务数量。<br>并行就是在同一个时刻，允许多个任务同时执行。</p>
</blockquote>
<blockquote>
<p>在多核CPU的架构里面，同时执行任务的数量是由CPU的核心数量决定的。<br>比如说四核四线程的CPU里面，只能同时执行四个线程。<br>并发描述的是程序处理能力的视角。<br>而并行描述的是CPU处理任务方式的一个视角。<br>它们两个相辅相成，CPU并行执行任务的能力又能够提升程序的并发处理性能。<br>所以多核CPU的性能要比单核CPU要好。<br>如果是单核CPU也可以通过时间片切换的方式去提升并发的能力。</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_38192821/article/details/130538395?spm=1001.2014.3001.5501">木子丶鹏</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
